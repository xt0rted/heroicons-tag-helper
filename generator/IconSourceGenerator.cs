namespace IconSourceGenerator;

using AllIcons = List<(string name, string className)>;
using IconMap = Dictionary<string, List<IconDetails>>;

[Generator]
public class IconSourceGenerator : ISourceGenerator
{
    private static readonly DiagnosticDescriptor _errorDescriptor = new(
        "SI0000",
        "Error in the IconSourceGenerator generator",
        "Error in the IconSourceGenerator generator: '{0}'",
        "IconSourceGenerator",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true);

    public void Execute(GeneratorExecutionContext context)
    {
        try
        {
            ExecuteInternal(context);
        }
        catch (Exception ex)
        {
            context.ReportDiagnostic(Diagnostic.Create(_errorDescriptor, Location.None, ex.ToString()));
        }
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private void ExecuteInternal(GeneratorExecutionContext context)
    {
        var obsoleteIcons = LoadObsoleteIconList(context);
        var icons = LoadIcons(context);

        // Merge all icon names into a single list
        var allIcons = icons
            .SelectMany(i => i.Value.Select(i => (i.Name, i.ClassName)))
            .Distinct()
            .OrderBy(i => i)
            .ToList();

        AddSupportingFiles(context);
        BuildSymbolEnum(context, allIcons, obsoleteIcons);
        BuildIconListClass(context, allIcons, icons);
    }

    private List<string>? LoadObsoleteIconList(GeneratorExecutionContext context)
        => context
            .AdditionalFiles
            .Where(at => at.Path.EndsWith("obsolete_icons.txt", StringComparison.InvariantCultureIgnoreCase))
            .Select(file =>
            {
                var text = file.GetText(context.CancellationToken);

                if (text is null)
                {
                    throw new Exception("Obsolete icon file could not be read.");
                }

                return text
                    .Lines
                    .Select(line => line.ToString())
                    .ToList();
            })
            .FirstOrDefault();

    private IconMap LoadIcons(GeneratorExecutionContext context)
        => context
            .AdditionalFiles
            .Where(at => at.Path.EndsWith(".svg", StringComparison.InvariantCultureIgnoreCase))
            .Select(file =>
            {
                var options = context.AnalyzerConfigOptions.GetOptions(file);
                if (!options.TryGetValue("build_metadata.AdditionalFiles.IconStyle", out var iconStyle))
                {
                    throw new Exception($"IconStyle not specified for file {file.Path}");
                }

                context.AnalyzerConfigOptions.GetOptions(file).TryGetValue("build_metadata.AdditionalFiles.UsesStroke", out var usesStrokeValue);
                bool.TryParse(usesStrokeValue, out var usesStroke);

                var directory = Path.GetDirectoryName(file.Path);
                var name = Path.GetFileNameWithoutExtension(file.Path);

                return new IconDetails
                {
                    ClassName = name.ToPascalCase(),
                    File = file,
                    Name = name,
                    Path = file.Path,
                    Style = iconStyle,
                    UsesStroke = usesStroke,
                };
            })
            .OrderBy(o => o.Style)
            .ThenBy(o => o.Name)
            .GroupBy(g => g.Style)
            .ToDictionary(k => k.Key, k => k.ToList());

    private void AddSupportingFiles(GeneratorExecutionContext context)
    {
        const string iconClassSource = """
            // <auto-generated />
            namespace Tailwind.Heroicons;

            /// <summary>
            /// A parsed Heroicon.
            /// </summary>
            public class Icon
            {
                /// <summary>
                /// The filename without extension.
                /// </summary>
                public string Name { get; set; }

                /// <summary>
                /// The svg path element.
                /// </summary>
                public string Path { get; set; }

                /// <summary>
                /// The svg <c>viewbox</c> attribute value.
                /// </summary>
                public string ViewBox { get; set; }

                /// <summary>
                /// The svg <c>stroke-width</c> attribute value.
                /// </summary>
                public string StrokeWidth { get; set; }
            }
            """;

        const string iconExceptionSource = """
            // <auto-generated />
            namespace Tailwind.Heroicons;

            /// <summary>
            /// The exception that is thrown when an icon is not supported in the given set.
            /// </summary>
            public class UnsupportedIconException : Exception
            {
                /// <summary>
                /// Initializes a new instance of the <see cref="UnsupportedIconException"/> class with a specified icon style and name.
                /// </summary>
                /// <param name="style">The icon style/set.</param>
                /// <param name="name">The icon name.</param>
                public UnsupportedIconException(string style, string name)
                    : base($"Icon '{name}' doesn't have a {style} style.")
                {
                    new ArrayTypeMismatchException("");
                    Style = style;
                    Name = name;
                }

                /// <summary>
                /// The set that the icon is missing from.
                /// </summary>
                public string Style { get; set; } = null!;

                /// <summary>
                /// The name of the icon.
                /// </summary>
                public string Name { get; set; } = null!;
            }
            """;

        context.AddSource("Icon", SourceText.From(iconClassSource, Encoding.UTF8));
        context.AddSource("UnsupportedIconException", SourceText.From(iconExceptionSource, Encoding.UTF8));
    }

    private void BuildSymbolEnum(
        GeneratorExecutionContext context,
        AllIcons allIcons,
        List<string>? obsoleteIcons)
    {
        var source = new StringBuilder(
            """
            // <auto-generated />
            namespace Tailwind.Heroicons;

            /// <summary>
            /// The available icons.
            /// </summary>
            public enum IconSymbol
            {

            """);

        foreach (var (name, className) in allIcons)
        {
            source.AppendLine("    /// <summary>");
            source.AppendLine("    /// Heroicon name: ", name);
            source.AppendLine("    /// </summary>");

            if (obsoleteIcons?.Contains(name) is true)
            {
                source.AppendLine("    [Obsolete(\"Icon '", name, "' is now an alias and will be removed in a future version. See the Heroicons release notes for more information.\")]");
            }

            source.AppendLine("    ", className, ",");
            source.AppendLine();
        }

        source.AppendLine("}");

        context.AddSource("IconSymbol", SourceText.From(source.ToString(), Encoding.UTF8));
    }

    private void BuildIconListClass(
        GeneratorExecutionContext context,
        AllIcons allIcons,
        IconMap icons)
    {
        var source = new StringBuilder(
            """
            #pragma warning disable CS0618

            // <auto-generated />
            namespace Tailwind.Heroicons;

            using System;

            /// <summary>
            /// Helper used to get parsed icon details.
            /// </summary>
            public static class IconList
            {

            """);

        foreach (var style in icons)
        {
            source.AppendLine("    /// <summary>");
            source.AppendLine("    /// Get the details of an icon in the ", style.Key.FirstCharToUpper(), " variation.");
            source.AppendLine("    /// </summary>");
            source.AppendLine("    /// <param name=\"symbol\">The <see cref=\"IconSymbol\"/> to get the details of.</param>");
            source.AppendLine("    /// <returns>The icon details.</returns>");
            source.AppendLine("    public static Icon ", style.Key.FirstCharToUpper(), "(IconSymbol symbol)");
            source.AppendLine(
                """
                    {
                        switch (symbol)
                        {
                """);

            foreach (var (name, className) in allIcons)
            {
                var icon = style.Value.Find(i => i.Name == name);

                source.AppendLine("            case IconSymbol.", className, ":");

                if (icon is null)
                {
                    source.AppendLine("                throw new UnsupportedIconException(\"", style.Key, "\", \"", name, "\");");
                }
                else
                {
                    var file = icon.File.GetText(context.CancellationToken)!.ToString();
                    var path = IconExtractor.GetPaths(file);
                    var viewBox = IconExtractor.GetViewBox(file);

                    source.AppendLine("                return new Icon");
                    source.AppendLine("                {");
                    source.AppendLine("                    Name = \"", name, "\",");
                    source.AppendLine("                    Path = \"\"\"", path, "\"\"\",");
                    source.AppendLine("                    ViewBox = \"", viewBox, "\",");

                    if (icon.UsesStroke)
                    {
                        var strokeWidth = IconExtractor.GetStrokeWidth(file);

                        source.AppendLine("                    StrokeWidth = \"", strokeWidth, "\",");
                    }

                    source.AppendLine("                };");
                }

                source.AppendLine();
            }

            source.AppendLine(
                """
                            default:
                                throw new ArgumentOutOfRangeException(nameof(symbol), symbol, "Unsupported icon name");
                        }
                    }
                """);
        }

        source.AppendLine("}");

        context.AddSource("IconList", SourceText.From(source.ToString(), Encoding.UTF8));
    }

#pragma warning disable RCS1016 // Use block body or expression body.
    public void Initialize(GeneratorInitializationContext context)
    {
        // System.Diagnostics.Debugger.Launch();
    }
#pragma warning restore RCS1016 // Use block body or expression body.
}
